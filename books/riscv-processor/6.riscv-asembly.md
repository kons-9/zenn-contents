---
title: "簡単なC言語の命令をアセンブラに変換する"
---

# 簡単なC言語の命令をアセンブラに変換する
この章では、簡単なC言語の命令をアセンブラに変換してみます。
なおこの章は必須ではありません。
早く実装がしたい場合は次の章へ行き、実装を進めることをおすすめします。

対象となる関数はfibonacci関数です。
```c
int fibonacci(int n) {
    if (n <= 1) {
        return n;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}
```
コンパイラは非常に便利なウェブアプリである`https://godbolt.org/`上でRISC-V rv64gc clang20.1.0を用いてコンパイルします。
このウェブアプリではC言語のソースコード上の行とアセンブラの行を対応させて表示してくれます。すごいですね。

結果はこんな感じです。じゃん。
```assembly
fibonacci(int):
        addi    sp, sp, -32
        sw      ra, 28(sp)
        sw      s0, 24(sp)
        addi    s0, sp, 32
        sw      a0, -16(s0)
        lw      a1, -16(s0)
        li      a0, 1
        blt     a0, a1, .LBB0_2
        j       .LBB0_1
.LBB0_1:
        lw      a0, -16(s0)
        sw      a0, -12(s0)
        j       .LBB0_3
.LBB0_2:
        lw      a0, -16(s0)
        addi    a0, a0, -1
        call    fibonacci(int)
        sw      a0, -20(s0)
        lw      a0, -16(s0)
        addi    a0, a0, -2
        call    fibonacci(int)
        mv      a1, a0
        lw      a0, -20(s0)
        add     a0, a0, a1
        sw      a0, -12(s0)
        j       .LBB0_3
.LBB0_3:
        lw      a0, -12(s0)
        lw      ra, 28(sp)
        lw      s0, 24(sp)
        addi    sp, sp, 32
        ret
```

はじめて見た人は、何が何だか分からないと思います。
最初から見ていきましょう。

## 関数の呼び方
関数呼び出しはどのように実現されるのでしょうか。
関数には一般に入力と出力があります。
この呼び出しをうまく渡す必要があります。
では引数が2つの関数呼び出しをこのようにしてみましょう。
```
call func arg1 arg2
```
このように命令を定義すれば確かに関数呼び出しが実現できます。

しかし、一般の関数呼び出しは引数の数が固定ではありません。
例えば仮に10個の関数呼び出しを見てみましょう。
```
call func arg1 arg2 ... arg10
```
このような関数呼び出しはいかがでしょうか？
c言語上では確かに
```
func(arg1, arg2, ... , arg10);
```
と書くため、アセンブリも同様に定義してもいいと思われる方がいるかもしれません。
ではなぜ行けないのでしょう。

答えは、「RISC-Vでは命令をハードウェアで効率的に処理するために命令の長さに制限があるから」です。

アセンブリ言語は機械語に直接対応する言語です。
このためアセンブリの仕様が機械語の仕様だと考えることができます。
すなわちアセンブリ言語はハードウェアで処理するべき内容を決めているということです。

機械語が可変長だと、論理回路で可変長のデータを処理する必要が出てきます。
もちろん、このような回路を組むことは可能です。
しかし、一般にハードウェアは可変長よりも固定長のデータを好みます。
このため、RISC-Vでは上記のような関数呼び出しではない方法をとっています。

### 可変長データを扱う
ソフトウェア的に呼び出すことはしないことがわかりました。
では可変長データをどのように扱うのでしょう。

RISC-Vの関数呼び出しは一つの命令で処理しないことで可変長データを扱います。
命令数を可変にすることによって、可変長のデータを扱っているのです。
前章の内容で、CPUは状態と状態遷移によりできている、と言いました。
状態を段階的に変化させることで引数の情報を処理させているのです。

では「上記の関数はメモリの11番地以降に引数を配置する」としてみましょう。
つまり、疑似コード的にはRxにx番目の引数が入っているとすると、9個関数呼び出しがある場合は
```
STORE R1 0x0011
STORE R2 0x0012
...
STORE R9 0x0019
CALL  func
```
のようなコードで呼び出し、引数x番を使いたい場合は
```
LOAD RX 0x001x
```
のようにすることで、所望の引数を取得できることになります。

確かにこのコードでも実現することは可能です。
しかしすべてをこのような方法にするとどうなるでしょう。

まず挙げられる弱点としては、アドレスの配置を決めなければ行けないことです。
メモリ配置を決める工数がかかり、かつ保守が難しくなります。
この弱点は、メモリ配置を自動化することで解決できます。((実際、関数呼び出しではないですが、c言語のglobal変数はこのような仕組みです))

次に挙げられる弱点として、再帰関数が使えないことです。
再帰関数とは、自身の関数処理のなかで自身の関数を呼び出す関数のことです。
上記の関数呼び出しでは固定のアドレスであるため、自身の関数を呼び出すともとの引数情報が上書きされてしまいます。
この弱点は何度呼び出されたのかを、メモリ番地0x0010においておき、それに対応する番地をアドレスとすることで解決可能です。
例えば、R1の情報を保持するときには
```
// r10 = *(size_t *)0x0010
LOAD R10 0x0010
// r11 = r10 * 10
MUL R11 R10 10
// r11 += 1
ADD R11 R11 1
// *(r11) = r1
STORE R1 R11
```
このような形で計算することでかぶりなく保存することが可能です。

次に挙げられる弱点としては、同時にn個動かせないことです。
並行処理を行うと、同時に複数個の同じプログラムが走ります。先程の再帰関数のように呼び出し順が決まっていないためカウンタは使用できません。
解決策としてはこの領域のアドレスを共有しないことが挙げられます。
自身のアドレス空間を持つことで上書きすることを防ぐことができます。

私が思うもっと本質的な弱点としてはメモリの再利用が困難なことです。
関数ローカルな情報は関数呼び出しの中で際にのみ使います。
したがって、メモリに常駐するのはメモリの無駄遣いです。
静的にメモリ配置を決めてしまった場合、うまく再利用するのは非常に難しいです。

### 本当の呼び出し方
長々と焦らす形になってしまいました。
CPUでは引数の保存をスタックと一部のレジスタを用いて解決しています。
スタックとはデータ構造の一つで、後入れ先出しの性質を持つものです。
スタックに関数の引数を入れておくことで関数呼び出しを実現しています。

ここからは実際のコードで確認していきましょう。
```assembly
fibonacci(int):
        addi    sp, sp, -32     // sp = sp - 32
        sw      ra, 28(sp)      // *(sp+28) = ra
        sw      s0, 24(sp)      // *(sp+24) = s0
        addi    s0, sp, 32      // s0 = sp + 32
        sw      a0, -16(s0)     // *(s0-16) = a0
        lw      a1, -16(s0)     // a1 = *(s0-16)
        li      a0, 1           // a0 = 1
        blt     a0, a1, .LBB0_2 // a0 < a1ならば、.LBB0_2へ
        j       .LBB0_1         // .LBB0_1へ
.LBB0_1:
        lw      a0, -16(s0)     // a0 = *(s0-16)
        sw      a0, -12(s0)     // *(s0-12) = a0
        j       .LBB0_3         // .LBB0_3へ
.LBB0_2:
        lw      a0, -16(s0)     // a0 = *(s0-16)
        addi    a0, a0, -1      // a0 = a0 - 1
        call    fibonacci(int)  // fibonacci(int)を呼び出し
        sw      a0, -20(s0)     // *(s0-20) = a0
        lw      a0, -16(s0)     // a0 = *(s0-16)
        addi    a0, a0, -2      // a0 = a0 - 2
        call    fibonacci(int)  // fibonacci(int)を呼び出し
        mv      a1, a0          // a1 = a0
        lw      a0, -20(s0)     // a0 = *(s0-20)
        add     a0, a0, a1      // a0 = a0 + a1
        sw      a0, -12(s0)     // *(s0-12) = a0
        j       .LBB0_3         // .LBB0_3へ
.LBB0_3:
        lw      a0, -12(s0)     // a0 = *(s0-12)
        lw      ra, 28(sp)      // ra = *(sp+28)
        lw      s0, 24(sp)      // s0 = *(sp+24)
        addi    sp, sp, 32      // sp = sp + 32
        ret                     // 戻り値を返す
```

CPUのスタックを使うときに必要なポインタが、スタックポインタ(sp, stack pointer)です。
スタックポインタはスタックの先頭アドレスを指すポインタのことです。
スタックポインタは、関数の引数を保持するための領域を確保するために、spを-32します。

このような呼び出し規則のことをCalling Conventionといいます。
また、アセンブリレベルで移植性があるようにするための決まりをABIといいます。
